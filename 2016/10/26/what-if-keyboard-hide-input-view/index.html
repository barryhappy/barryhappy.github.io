<!DOCTYPE html><html lang="zh-cn"><head><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><title> Android爬坑之旅：软键盘挡住输入框问题的终极解决方案 · Barry's Blog</title><meta name="description" content="Android爬坑之旅：软键盘挡住输入框问题的终极解决方案 - Barry Zhang"><meta name="viewport" content="width=device-width, initial-scale=1"><link rel="short icon" href="https://avatars0.githubusercontent.com/u/5143676?v=3&amp;s=466"><link rel="stylesheet" href="/css/apollo.css"><link rel="search" type="application/opensearchdescription+xml" href="http://barryhappy.github.io/atom.xml" title="Barry's Blog"></head><body><div class="wrap"><header><a href="/" class="logo-link"><img src="https://avatars0.githubusercontent.com/u/5143676?v=3&amp;s=466"></a><ul class="nav nav-list"><li class="nav-list-item"><a href="/" target="_self" class="nav-list-link">BLOG</a></li><li class="nav-list-item"><a href="/archives/" target="_self" class="nav-list-link">ARCHIVE</a></li><li class="nav-list-item"><a href="https://github.com/barryhappy" target="_blank" class="nav-list-link">GITHUB</a></li><li class="nav-list-item"><a href="/atom.xml" target="_self" class="nav-list-link">RSS</a></li><li class="nav-list-item"><a href="http://www.barryzhang.com/" target="_blank" class="nav-list-link">BARRYZHANG</a></li></ul></header><section class="container"><div class="post"><article class="post-block"><h1 class="post-title">Android爬坑之旅：软键盘挡住输入框问题的终极解决方案</h1><div class="post-info">2016年10月26日</div><div class="post-content"><blockquote>
<p>本文由<a href="https://github.com/barryhappy" target="_blank" rel="external">BarryZhang</a>原创，同时首发于diycode.cc、barryzhang.com 、github.com/barryhappy，非商业转载请注明作者和原文链接。</p>
</blockquote>
<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>开发做得久了，总免不了会遇到各种坑。<br>而在Android开发的路上，『软键盘挡住了输入框』这个坑，可谓是一个旷日持久的巨坑——来来来，我们慢慢看。</p>
<a id="more"></a> 
<h1 id="入门篇"><a href="#入门篇" class="headerlink" title="入门篇"></a>入门篇</h1><p><img src="http://barryzhang.qiniudn.com/QQ20161024-0.png" alt="Base"></p>
<p>最基本的情况，如图所示：在页面底部有一个EditText，如果不做任何处理，那么在软键盘弹出的时候，就有可能会挡住EditText。<br>对于这种情况的处理其实很简单，只需要在AndroidManifest文件中对activity设置：<code>android:windowSoftInputMode</code>的值<code>adjustPan</code>或者<code>adjustResize</code>即可，像这样：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">activity</span></span></div><div class="line">	<span class="attr">android:name</span>=<span class="string">".MainActivity"</span></div><div class="line">	<span class="attr">android:windowSoftInputMode</span>=<span class="string">"adjustPan"</span>  &gt;</div><div class="line">    ...</div><div class="line"><span class="tag">&lt;/<span class="name">activity</span>&gt;</span></div></pre></td></tr></table></figure>
<p>一般来说，他们都可以解决问题，当然，<code>adjustPan</code>跟<code>adjustResize</code>的效果略有区别。 </p>
<ul>
<li><code>adjustPan</code>是把整个界面向上平移，使输入框露出，不会改变界面的布局；</li>
<li><code>adjustResize</code>则是重新计算弹出软键盘之后的界面大小，相当于是用更少的界面区域去显示内容，输入框一般自然也就在内了。</li>
</ul>
<p>↑↑↑ OK，这只是入门，基本上地球上所有的Android工程师都能搞定。<br>别急，看下面~</p>
<h1 id="加上WebView试试看？坑来了……"><a href="#加上WebView试试看？坑来了……" class="headerlink" title="加上WebView试试看？坑来了……"></a>加上WebView试试看？坑来了……</h1><h2 id="情况描述"><a href="#情况描述" class="headerlink" title="情况描述"></a>情况描述</h2><p>上面的入门篇中，软键盘是由原生的EditText触发弹出的。而在H5、Hybrid几乎已经成为App标配的时候，我们经常还会碰到的情况是：<strong>软键盘是由WebView中的网页元素所触发弹出的</strong>。  </p>
<p>这时候，情况就会变得复杂了: </p>
<ol>
<li>首先，页面是<code>非全屏模式</code>的情况下，给activity设置<code>adjustPan</code>会失效。</li>
<li>其次，页面是<code>全屏模式</code>的情况，<code>adjustPan</code>跟<code>adjustResize</code>都会失效。</li>
</ol>
<p>——解释一下，这里的<code>全屏模式</code>即是页面是全屏的，包括Application或activity使用了Fullscreen主题、使用了『状态色着色』、『沉浸式状态栏』、『Immersive Mode』等等——总之，基本上只要是App自己接管了状态栏的控制，就会产生这种问题。 </p>
<p>下面这个表格可以简单列举了具体的情况。 </p>
<p><img src="http://barryzhang.qiniudn.com/14773156950939.jpg" alt="表格"></p>
<h2 id="为什么说它是个坑？”issue-5497”"><a href="#为什么说它是个坑？”issue-5497”" class="headerlink" title="为什么说它是个坑？”issue 5497”"></a>为什么说它是个坑？”issue 5497”</h2><p>上面表格的这种情况并非是Google所期望的，理想的情况当然是它们都能正常生效才对——所以这其实是Android系统本身的一个BUG。 </p>
<p>为什么文章开头说这是个坑呢？<br>——因为这个BUG从Android1.x时代（2009年）就被报告了，而一直到了如今的Android7.0（2016年）还是没有修复……/(ㄒoㄒ)/<br>可以说这不仅是个坑，而且还是个官方挖的坑~</p>
<p>“issue 5497”，详情传送门 ☞ <a href="https://code.google.com/p/android/issues/detail?id=5497" target="_blank" rel="external">Issue 5497 - android -WebView adjustResize windowSoftInputMode breaks when activity is fullscreen - Android Open Source Project - Issue Tracker - Google Project Hosting</a></p>
<p>当然了，不管坑是谁挖的，最终还是要开发者来解决。</p>
<p>遇到坑之后，有两种方法可以过去：躲，或者填。</p>
<h1 id="躲坑姿势"><a href="#躲坑姿势" class="headerlink" title="躲坑姿势"></a>躲坑姿势</h1><p>如前文所示，出现坑的条件是：带有WebView的activity使用了<code>全屏模式</code>或者<code>adjustPan</code>模式。<br>那么躲坑的姿势就很简单了——<br>    <strong>如果activity中有WebView，就不要使用<code>全屏模式</code>，并且把它的windowSoftInputMode值设为<code>adjustResize</code>就好了嘛</strong></p>
<p>怎么样，是不是很简单？😑<br><img src="http://barryzhang.qiniudn.com/20130927092846557.jpg" alt="20130927092846557"></p>
<h1 id="填坑姿势"><a href="#填坑姿势" class="headerlink" title="填坑姿势"></a>填坑姿势</h1><p>但总有些时候，是需要<code>全屏模式</code>跟WebView兼得的，这时候，躲坑就不行了，我们需要一个新的填坑的姿势。幸好，开发者的智慧是无穷的，这个坑出现了这么多年，还是有人找到了一些解决方案的。 </p>
<h2 id="AndroidBug5497Workaround"><a href="#AndroidBug5497Workaround" class="headerlink" title="AndroidBug5497Workaround"></a>AndroidBug5497Workaround</h2><p>我个人认为最好的解决方案是这个：<a href="http://stackoverflow.com/a/19494006" target="_blank" rel="external">AndroidBug5497Workaround</a>，只需要一个神奇的<code>AndroidBug5497Workaround</code>类。</p>
<p>使用步骤：</p>
<ol>
<li>把<code>AndroidBug5497Workaround</code>类复制到项目中</li>
<li>在需要填坑的activity的onCreate方法中添加一句<code>AndroidBug5497Workaround.assistActivity(this)</code>即可。  </li>
</ol>
<p>经过测试，基本在各个Android版本上都可用，效果基本与设置了<code>adjustResize</code>相当。<br>看一个对比图：<br><img src="http://barryzhang.qiniudn.com/webview-compare.jpg" alt="效果对比图"></p>
<p>来自我厂App的某个使用WebView的<code>全屏模式</code>Activity页面，从左到右分别是：没有软键盘的样式、软键盘挡住输入框的效果、以及使用AndroidBug5497Workaround之后的最终效果。</p>
<h2 id="它的原理是什么？"><a href="#它的原理是什么？" class="headerlink" title="它的原理是什么？"></a>它的原理是什么？</h2><p>这个炫酷AndroidBug5497Workaround类，其实并不是很复杂，只有几十行代码，先贴在这里：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AndroidBug5497Workaround</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="comment">// For more information, see https://code.google.com/p/android/issues/detail?id=5497</span></div><div class="line">    <span class="comment">// To use this class, simply invoke assistActivity() on an Activity that already has its content view set.</span></div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">assistActivity</span> <span class="params">(Activity activity)</span> </span>&#123;</div><div class="line">        <span class="keyword">new</span> AndroidBug5497Workaround(activity);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">private</span> View mChildOfContent;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">int</span> usableHeightPrevious;</div><div class="line">    <span class="keyword">private</span> FrameLayout.LayoutParams frameLayoutParams;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">private</span> <span class="title">AndroidBug5497Workaround</span><span class="params">(Activity activity)</span> </span>&#123;</div><div class="line">        FrameLayout content = (FrameLayout) activity.findViewById(android.R.id.content);</div><div class="line">        mChildOfContent = content.getChildAt(<span class="number">0</span>);</div><div class="line">        mChildOfContent.getViewTreeObserver().addOnGlobalLayoutListener(<span class="keyword">new</span> ViewTreeObserver.OnGlobalLayoutListener() &#123;</div><div class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onGlobalLayout</span><span class="params">()</span> </span>&#123;</div><div class="line">                possiblyResizeChildOfContent();</div><div class="line">            &#125;</div><div class="line">        &#125;);</div><div class="line">        frameLayoutParams = (FrameLayout.LayoutParams) mChildOfContent.getLayoutParams();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">possiblyResizeChildOfContent</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">int</span> usableHeightNow = computeUsableHeight();</div><div class="line">        <span class="keyword">if</span> (usableHeightNow != usableHeightPrevious) &#123;</div><div class="line">            <span class="keyword">int</span> usableHeightSansKeyboard = mChildOfContent.getRootView().getHeight();</div><div class="line">            <span class="keyword">int</span> heightDifference = usableHeightSansKeyboard - usableHeightNow;</div><div class="line">            <span class="keyword">if</span> (heightDifference &gt; (usableHeightSansKeyboard/<span class="number">4</span>)) &#123;</div><div class="line">                <span class="comment">// keyboard probably just became visible</span></div><div class="line">                frameLayoutParams.height = usableHeightSansKeyboard - heightDifference;</div><div class="line">            &#125; <span class="keyword">else</span> &#123;</div><div class="line">                <span class="comment">// keyboard probably just became hidden</span></div><div class="line">                frameLayoutParams.height = usableHeightSansKeyboard;</div><div class="line">            &#125;</div><div class="line">            mChildOfContent.requestLayout();</div><div class="line">            usableHeightPrevious = usableHeightNow;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">computeUsableHeight</span><span class="params">()</span> </span>&#123;</div><div class="line">        Rect r = <span class="keyword">new</span> Rect();</div><div class="line">        mChildOfContent.getWindowVisibleDisplayFrame(r);</div><div class="line">        <span class="keyword">return</span> (r.bottom - r.top);<span class="comment">// 全屏模式下： return r.bottom</span></div><div class="line">    &#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>代码大致是做了这么几件事： </p>
<h3 id="1-找到activity的根View"><a href="#1-找到activity的根View" class="headerlink" title="1.找到activity的根View"></a>1.找到activity的根View</h3><p>看一下入口的代码：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">FrameLayout content = (FrameLayout) activity.findViewById(android.R.id.content);</div><div class="line">mChildOfContent = content.getChildAt(<span class="number">0</span>);</div></pre></td></tr></table></figure></p>
<p>其中，第一行中的<code>android.R.id.content</code>所指的View，是Android所有Activity界面上开发者所能控制的区域的根View。</p>
<blockquote>
<ul>
<li>如果Activity是<code>全屏模式</code>，那么android.R.id.content就是占满全部屏幕区域的。</li>
<li>如果Activity是普通的<code>非全屏模式</code>，那么android.R.id.content就是占满除状态栏之外的所有区域。</li>
<li>其他情况，如Activity是弹窗、或者7.0以后的分屏样式等，android.R.id.content也是弹窗的范围或者分屏所在的半个屏幕——这些情况较少，就暂且不考虑了。</li>
</ul>
</blockquote>
<p>我们经常用的setContentView(View view)/setContent(int layRes)其实就是把我们指定的View或者layRes放到android.R.id.content里面，成为它的子View。</p>
<p>所以，然后，第二行content.getChildAt(0)获取到的<code>mChildOfContent</code>，其实也就是用以获取到我们用setContentView放进去的View。</p>
<h3 id="2-设置一个Listener监听View树变化"><a href="#2-设置一个Listener监听View树变化" class="headerlink" title="2.设置一个Listener监听View树变化"></a>2.设置一个Listener监听View树变化</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">mChildOfContent.getViewTreeObserver().addOnGlobalLayoutListener(&#123; <span class="comment">//简化了写法</span></div><div class="line">        possiblyResizeChildOfContent();</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p>View.getViewTreeObserver()可以获取一个<code>ViewTreeObserver</code>对象——这个对象是一个观察者，专门用以监听当前View树所发生的一些变化。这里所注册的<code>addOnGlobalLayoutListener</code>，就是会在当前的View树的全局布局（GlobalLayout）发生变化、或者其中的View可视状态有变化时，进行通知回调。</p>
<p>——<strong>『软键盘弹出』，则是会触发这个事件的一个源。</strong> (软键盘弹出会使GlobalLayout发生变化)</p>
<p>也就是说，现在能监听到『软键盘弹出』的事件了。 </p>
<h3 id="3-界面变化之后，获取”可用高度”"><a href="#3-界面变化之后，获取”可用高度”" class="headerlink" title="3.界面变化之后，获取”可用高度”"></a>3.界面变化之后，获取”可用高度”</h3><p>当软键盘弹出了之后，接下来的事情是获取改变之后的界面的<code>可用高度</code>（可以被开发者用以显示内容的高度）。<br>直接看代码：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">computeUsableHeight</span><span class="params">()</span> </span>&#123;</div><div class="line">    Rect rect = <span class="keyword">new</span> Rect();</div><div class="line">    mChildOfContent.getWindowVisibleDisplayFrame(rect);</div><div class="line">    <span class="comment">// rect.top其实是状态栏的高度，如果是全屏主题，直接 return rect.bottom就可以了</span></div><div class="line">    <span class="keyword">return</span> (rect.bottom - rect.top);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>View.getWindowVisibleDisplayFrame(Rect rect)，这行代码能够获取到的Rect——就是界面除去了标题栏、除去了被软键盘挡住的部分，所剩下的矩形区域——如图所示，红框中的区域。<br><img src="http://barryzhang.qiniudn.com/QQ20161025.jpg" alt="Rect区域示意图"></p>
<p>↑也可以看出：</p>
<ul>
<li>rect.top值，其实就是标题栏的高度。（实际上，这也常常被用作为获取标题栏高度的方法）</li>
<li>屏幕高度-rect.bottom，是软键盘的高度。（获取软键盘高度的方法也出现了）</li>
</ul>
<p>这时，就有：</p>
<ul>
<li><code>全屏模式</code>下，<code>可用高度</code> = rect.bottom </li>
<li>非<code>全屏模式</code>，<code>可用高度</code> = rect.bottom - rect.top</li>
</ul>
<h3 id="4-最后一步，重设高度"><a href="#4-最后一步，重设高度" class="headerlink" title="4.最后一步，重设高度"></a>4.最后一步，重设高度</h3><p>我们计算出的<code>可用高度</code>，是目前在视觉效果上能看到的界面高度。但当前界面的实际高度是比<code>可用高度</code>要多出一个软键盘的距离的。<br>所以，最后一步，就是把界面高度置为<code>可用高度</code>——大功告成。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">possiblyResizeChildOfContent</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="keyword">int</span> usableHeightNow = computeUsableHeight();</div><div class="line">    <span class="keyword">if</span> (usableHeightNow != usableHeightPrevious) &#123;</div><div class="line">        <span class="keyword">int</span> usableHeightSansKeyboard = mChildOfContent.getRootView().getHeight();</div><div class="line">        <span class="keyword">int</span> heightDifference = usableHeightSansKeyboard - usableHeightNow;</div><div class="line">        <span class="keyword">if</span> (heightDifference &gt; (usableHeightSansKeyboard/<span class="number">4</span>)) &#123;</div><div class="line">            <span class="comment">// keyboard probably just became visible</span></div><div class="line">            frameLayoutParams.height = usableHeightSansKeyboard - heightDifference;</div><div class="line">        &#125; <span class="keyword">else</span> &#123;</div><div class="line">            <span class="comment">// keyboard probably just became hidden</span></div><div class="line">            frameLayoutParams.height = usableHeightSansKeyboard;</div><div class="line">        &#125;</div><div class="line">        mChildOfContent.requestLayout();</div><div class="line">        usableHeightPrevious = usableHeightNow;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>上面的代码里添加了一个”heightDifference &gt; (usableHeightSansKeyboard/4)”的判断，这是为了去除无谓的干扰。因为能触发OnGlobalLayout事件的原因有很多，不止是软键盘的弹出变化，还包括各种子View的隐藏显示变化等，它们对界面高度的影响有限。加上了这个判断之后，只有界面的高度变化超过1/4的屏幕高度，才会进行重新设置高度，基本能保证代码只响应软键盘的弹出。</p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>总结起来，就是这样：</p>
<ol>
<li>普通Activity（不带WebView），直接使用<code>adjustpan</code>或者<code>adjustResize</code></li>
<li>如果带WebView：   <ul>
<li>a) 如果非<code>全屏模式</code>，可以使用<code>adjustResize</code></li>
<li>b) 如果是<code>全屏模式</code>，则使用<code>AndroidBug5497Workaround</code>进行处理。</li>
</ul>
</li>
</ol>
<p>OK，以上就是一段关于『软键盘挡住输入框』的爬坑之旅。</p>
<h1 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h1><p>有用的链接：<br><a href="https://code.google.com/p/android/issues/detail?id=5497" target="_blank" rel="external">https://code.google.com/p/android/issues/detail?id=5497</a><br><a href="http://stackoverflow.com/a/19494006" target="_blank" rel="external">http://stackoverflow.com/a/19494006</a><br><a href="https://developer.android.com/reference/android/view/ViewTreeObserver.html" target="_blank" rel="external">https://developer.android.com/reference/android/view/ViewTreeObserver.html</a></p>
</div></article></div></section><footer><div class="paginator"><a href="/2016/11/19/difference-of-startactivityforresult-bettwen-fragment-activity/" class="prev">上一篇</a><a href="/2016/10/21/why-we-need-kotlin/" class="next">下一篇</a></div><div class="copyright"><p>© 2015 - 2017 <a href="http://barryhappy.github.io">Barry Zhang</a>, powered by <a href="https://hexo.io/" target="_blank">Hexo</a> and <a href="https://github.com/pinggod/hexo-theme-apollo" target="_blank">hexo-theme-apollo</a>.</p></div></footer></div><script async src="//cdn.bootcss.com/mathjax/2.6.1/MathJax.js?config=TeX-MML-AM_CHTML"></script><script>(function(b,o,i,l,e,r){b.GoogleAnalyticsObject=l;b[l]||(b[l]=function(){(b[l].q=b[l].q||[]).push(arguments)});b[l].l=+new Date;e=o.createElement(i);r=o.getElementsByTagName(i)[0];e.src='//www.google-analytics.com/analytics.js';r.parentNode.insertBefore(e,r)}(window,document,'script','ga'));ga('create',"UA-65933410-1",'auto');ga('send','pageview');</script></body></html>